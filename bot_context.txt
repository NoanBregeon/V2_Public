===== index.js =====
require('dotenv').config();
const { Client, GatewayIntentBits, Partials, Collection, ActivityType, Events } = require('discord.js');

const client = new Client({
  intents: [
    GatewayIntentBits.Guilds,
    GatewayIntentBits.GuildMembers,
    GatewayIntentBits.GuildMessages,
    GatewayIntentBits.GuildMessageReactions,
    GatewayIntentBits.GuildVoiceStates,
    GatewayIntentBits.MessageContent
  ],
  partials: [Partials.Channel, Partials.GuildMember, Partials.Message, Partials.Reaction, Partials.User]
});

client.commands = new Collection();

const commandHandler = require('./handlers/commandHandler');
const ticketButtons = require('./handlers/ticketButtons');
const logEvents = require('./handlers/logEvents');
const { startTwitchRelay } = require('./services/twitchChat');


commandHandler.register(client);
ticketButtons.register(client);
logEvents.register(client);
// âœ… Compatible v14 et prÃªt pour v15
client.once(Events.ClientReady, () => {
  console.log(`âœ… ConnectÃ© en tant que ${client.user.tag}`);
  client.user.setPresence({
    activities: [{ name: 'Discord + Twitch', type: ActivityType.Watching }],
    status: 'online'
  });

  // ðŸ” On dÃ©marre le relay Twitch -> Discord
  startTwitchRelay(client);
});


client.login(process.env.DISCORD_TOKEN);
require('./handlers/ticketButtons').register(client);

require('./handlers/voiceTemp').register(client);
===== handlers/voiceTemp.js =====
// handlers/voiceTemp.js
const { ChannelType, PermissionFlagsBits } = require('discord.js');
const fs = require('fs');
const path = require('path');

const DATA_FILE = path.join(__dirname, '../data/voiceRooms.json');

// =========================
// STORAGE
// =========================
let store = { rooms: {} };

function loadStore() {
  try {
    store = JSON.parse(fs.readFileSync(DATA_FILE, 'utf8'));
  } catch {
    store = { rooms: {} };
  }
}

function saveStore() {
  fs.writeFileSync(DATA_FILE, JSON.stringify(store, null, 2));
}

function registerRoom(channelId, ownerId) {
  store.rooms[channelId] = {
    owner: ownerId,
    created: Date.now()
  };
  saveStore();
}

function unregisterRoom(channelId) {
  if (store.rooms[channelId]) {
    delete store.rooms[channelId];
    saveStore();
  }
}

function isOwner(channelId, userId) {
  return store.rooms[channelId]?.owner === userId;
}

function userAlreadyHasRoom(userId) {
  return Object.values(store.rooms).some(r => r.owner === userId);
}

// =========================
// INFO MESSAGE (Text-in-Voice)
// =========================
function sendVoiceInfoMessage(voiceChannel, ownerId) {
  setTimeout(async () => {
    try {
      if (typeof voiceChannel.send !== 'function') return;

      await voiceChannel.send({
        content:
          `ðŸŽ§ **Salon vocal crÃ©Ã© !**\n` +
          `<@${ownerId}>, tu es le propriÃ©taire de ce salon.\n\n` +
          `ðŸ“Œ **Commandes disponibles :**\n` +
          `â€¢ \`/rename <nom>\` â†’ Renommer le salon\n` +
          `â€¢ \`/limit <nombre>\` â†’ Limiter le nombre de personnes\n` +
          `â€¢ \`/lock\` â†’ Verrouiller le salon\n` +
          `â€¢ \`/unlock\` â†’ DÃ©verrouiller le salon\n\n` +
          `ðŸ—‘ï¸ Le salon sera automatiquement supprimÃ© quand il sera vide.`
      });
    } catch (err) {
      console.error('[voiceTemp] sendVoiceInfoMessage error:', err);
    }
  }, 1000);
}

// =========================
// OWNER TRANSFER
// =========================
function transferOwnership(channel, newOwnerId) {
  if (!store.rooms[channel.id]) return;

  store.rooms[channel.id].owner = newOwnerId;
  saveStore();

  channel.permissionOverwrites.edit(newOwnerId, {
    ViewChannel: true,
    Connect: true,
    ManageChannels: true,
    MoveMembers: true
  }).catch(() => {});
}

// =========================
// SAFE DELETE
// =========================
function deleteIfStillEmpty(channel, delay = 3000) {
  setTimeout(async () => {
    try {
      const fresh = await channel.guild.channels.fetch(channel.id).catch(() => null);
      if (!fresh) return;

      if (fresh.members.size === 0) {
        unregisterRoom(fresh.id);
        await fresh.delete('Salon vocal temporaire vide').catch(() => {});
      }
    } catch {
      // silence
    }
  }, delay);
}

// =========================
// INIT
// =========================
loadStore();

// =========================
// HANDLER
// =========================
module.exports = {
  register(client) {
    client.on('voiceStateUpdate', async (oldState, newState) => {
      try {
        const guild = newState.guild || oldState.guild;
        const member = newState.member || oldState.member;
        if (!guild || !member || member.user.bot) return;

        const createId = process.env.CREATE_VOICE_CHANNEL_ID;
        const categoryId = process.env.VOICE_CATEGORY_ID;
        if (!createId || !categoryId) return;

        const oldCh = oldState.channel;
        const newCh = newState.channel;

        // =========================
        // CREATE TEMP VOICE
        // =========================
        if (
          newCh &&
          newCh.id === createId &&
          (!oldCh || oldCh.id !== createId) &&
          !userAlreadyHasRoom(member.id)
        ) {
          const category = guild.channels.cache.get(categoryId);
          if (!category || category.type !== ChannelType.GuildCategory) return;

          const template = process.env.VOICE_NAME_TEMPLATE || 'ðŸ”Š {user}';
          const name = template.replace(
            '{user}',
            member.displayName || member.user.username
          );

          const voice = await guild.channels.create({
            name,
            type: ChannelType.GuildVoice,
            parent: categoryId,
            permissionOverwrites: [
              {
                id: guild.roles.everyone.id,
                allow: [
                  PermissionFlagsBits.ViewChannel,
                  PermissionFlagsBits.Connect
                ]
              },
              {
                id: member.id,
                allow: [
                  PermissionFlagsBits.ViewChannel,
                  PermissionFlagsBits.Connect,
                  PermissionFlagsBits.ManageChannels,
                  PermissionFlagsBits.MoveMembers
                ]
              }
            ],
            reason: `Salon vocal temporaire crÃ©Ã© pour ${member.user.tag}`
          });

          registerRoom(voice.id, member.id);
          await member.voice.setChannel(voice).catch(() => {});
          sendVoiceInfoMessage(voice, member.id);
          return;
        }

        // =========================
        // OWNER LEAVE / DELETE
        // =========================
        if (
          oldCh &&
          oldCh.parentId === categoryId &&
          oldCh.id !== createId
        ) {
          const room = store.rooms[oldCh.id];

          // transfert automatique si l'owner quitte
          if (room && room.owner === member.id) {
            const remaining = [...oldCh.members.values()].filter(m => m.id !== member.id);

            if (remaining.length > 0) {
              const newOwner = remaining[0];
              transferOwnership(oldCh, newOwner.id);

              if (typeof oldCh.send === 'function') {
                oldCh.send({
                  content: `ðŸ‘‘ <@${newOwner.id}> est maintenant propriÃ©taire du salon.`
                }).catch(() => {});
              }
            }
          }

          deleteIfStillEmpty(oldCh, 3000);
        }
      } catch (err) {
        console.error('[voiceTemp] error:', err);
      }
    });

    // =========================
    // API POUR COMMANDES /voice
    // =========================
    client.voiceTemp = {
      isOwner,
      getOwner(channelId) {
        return store.rooms[channelId]?.owner || null;
      },
      transferOwnership
    };
  }
};
===== handlers/commandHandler.js =====
const fs = require('fs');
const path = require('path');
const { REST, Routes, Collection, Events } = require('discord.js');
const { enforceAdmin } = require('../utils/permissions');

function collectCommands(dir, list = []) {
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  for (const e of entries) {
    const full = path.join(dir, e.name);
    if (e.isDirectory()) collectCommands(full, list);
    else if (e.isFile() && e.name.endsWith('.js')) list.push(full);
  }
  return list;
}

async function deployGuildCommands(client) {
  const guildId = process.env.GUILD_ID;
  const appId = process.env.DISCORD_CLIENT_ID;
  if (!guildId || !appId) {
    console.log('âš ï¸ GUILD_ID ou DISCORD_CLIENT_ID manquant â€” skip deploy.');
    return;
  }
  const body = [];
  client.commands.forEach(cmd => body.push(cmd.data.toJSON()));
  const rest = new REST({ version: '10' }).setToken(process.env.DISCORD_TOKEN);
  await rest.put(Routes.applicationGuildCommands(appId, guildId), { body });
  console.log(`ðŸ” Slash Commands dÃ©ployÃ©es sur la guilde ${guildId} (${client.commands.size} cmds)`);
}

module.exports.register = (client) => {
  const cmdFiles = collectCommands(path.join(__dirname, '..', 'commands'));
  for (const file of cmdFiles) {
    const mod = require(file);
    if (Array.isArray(mod)) {
      for (const c of mod) client.commands.set(c.data.name, c);
    } else if (mod?.data?.name) {
      client.commands.set(mod.data.name, mod);
    }
  }
  console.log(`ðŸ”— Loaded ${client.commands.size} commands`);

  client.on(Events.ClientReady, async () => {
    try {
      if (String(process.env.CLEAN_COMMANDS_ON_START).toLowerCase() === 'true') {
        await deployGuildCommands(client);
      }
    } catch (e) {
      console.error('deploy error:', e);
    }
  });

  client.on('interactionCreate', async (interaction) => {
    try {
      if (!interaction.isChatInputCommand()) return;
      const cmd = client.commands.get(interaction.commandName);
      if (!cmd) return;

      if (cmd.meta?.guildOnly && !interaction.guild) {
        return interaction.reply({ content: 'Commande serveur uniquement.', ephemeral: true });
      }
      if (cmd.meta?.adminOnly) {
        const ok = await enforceAdmin(interaction);
        if (!ok) return;
      }
      await cmd.execute(interaction);
    } catch (err) {
      console.error('interaction error:', err);
      if (interaction.replied || interaction.deferred) {
        interaction.followUp({ content: 'Erreur interne.', ephemeral: true }).catch(()=>{});
      } else {
        interaction.reply({ content: 'Erreur interne.', ephemeral: true }).catch(()=>{});
      }
    }
  });
};
===== commands/voice/lock.js =====

const { SlashCommandBuilder, PermissionFlagsBits } = require('discord.js');
module.exports = {
  data: new SlashCommandBuilder().setName('lock').setDescription('Verrouiller votre salon vocal').setDMPermission(false),
  meta: { guildOnly: true },
  async execute(interaction) {
    const me = await interaction.guild.members.fetch(interaction.user.id);
    const ch = me.voice?.channel;
    if (!ch || ch.type !== 2) return interaction.reply({ content: 'Rejoignez un salon vocal.', ephemeral: true });
    await ch.permissionOverwrites.edit(interaction.guild.roles.everyone, { Connect: false }).catch(()=>{});
    await interaction.reply({ content: 'Salon verrouillÃ©.', ephemeral: true });
  }
};
