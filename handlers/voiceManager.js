// VoiceManager.js
const { ChannelType, PermissionFlagsBits, EmbedBuilder } = require('discord.js');

class VoiceManager {
  /**
   * @param {import('discord.js').Client} client
   * @param {{ guildId: string, createVoiceChannelId: string, voiceInstructionsChannelId?: string }} config
   */
  constructor(client, config) {
    this.client = client;
    this.config = config;
    // channelId -> { owner: userId, created: timestamp }
    this.tempChannels = new Map();
  }

  async initialize() {
    // √âv√©nements vocaux
    this.client.on('voiceStateUpdate', this.handleVoiceStateUpdate.bind(this));

    // Nettoyer les canaux temporaires au d√©marrage
    await this.cleanupTempChannels();

    console.log('‚úÖ VoiceManager initialis√©');
  }

  async handleVoiceStateUpdate(oldState, newState) {
    // Cr√©ation du canal vocal temporaire
    if (newState.channelId === this.config.createVoiceChannelId) {
      await this.createTempChannel(newState);
      return;
    }

    // Si quitte un canal temporaire, v√©rifier s'il faut le supprimer
    if (oldState.channel && this.tempChannels.has(oldState.channelId)) {
      const tempChannel = oldState.channel;

      // Attendre un peu pour √©viter les suppressions lors des d√©placements
      setTimeout(async () => {
        try {
          const currentChannel = await this.client.channels.fetch(tempChannel.id).catch(() => null);
          if (currentChannel && currentChannel.members.size === 0) {
            await this.deleteTempChannel(tempChannel.id);
          }
        } catch (error) {
          console.error('‚ùå Erreur v√©rification canal temporaire:', error);
        }
      }, 1000);
    }
  }

  isTempChannel(channelId) {
    return this.tempChannels.has(channelId);
  }

  async createTempChannel(state) {
    const member = state.member;
    if (!member) return;

    try {
      // Cr√©er le canal vocal
      const channel = await state.guild.channels.create({
        name: `üîä Salon de ${member.displayName}`,
        type: ChannelType.GuildVoice,
        parent: state.channel?.parentId || state.channel?.parent || null,
        permissionOverwrites: [
          {
            id: state.guild.id, // @everyone
            allow: [PermissionFlagsBits.Connect, PermissionFlagsBits.Speak],
          },
          {
            id: member.id,
            allow: [
              PermissionFlagsBits.ManageChannels,
              PermissionFlagsBits.MuteMembers,
              PermissionFlagsBits.DeafenMembers,
              PermissionFlagsBits.ManageMessages,
              PermissionFlagsBits.MoveMembers,
            ],
          },
        ],
      });

      // D√©placer le membre dans le nouveau canal
      if (member.voice?.channelId !== channel.id) {
        await member.voice.setChannel(channel);
      }

      // Enregistrer le canal temporaire
      this.tempChannels.set(channel.id, {
        owner: member.id,
        created: Date.now(),
      });

      console.log(`üé§ Canal vocal temporaire cr√©√© par ${member.user.tag}: ${channel.name}`);

      // Envoyer les instructions
      await this.sendInstructions(member, channel);
    } catch (error) {
      console.error('‚ùå Erreur cr√©ation canal temporaire:', error);
    }
  }

  async deleteTempChannel(channelId) {
    try {
      const channel = this.client.channels.cache.get(channelId);
      if (channel) {
        await channel.delete();
        console.log(`üóëÔ∏è Canal vocal temporaire supprim√©: ${channel.name}`);
      }

      this.tempChannels.delete(channelId);
    } catch (error) {
      console.error('‚ùå Erreur suppression canal temporaire:', error);
    }
  }

  async cleanupTempChannels() {
    const guild = this.client.guilds.cache.get(this.config.guildId);
    if (!guild) return;

    try {
      // Vider la Map pour commencer proprement
      this.tempChannels.clear();

      // Recherche des canaux vides dans la m√™me cat√©gorie que le canal de cr√©ation
      const createChannel = guild.channels.cache.get(this.config.createVoiceChannelId);
      if (!createChannel) return;

      const categoryId = createChannel.parentId;
      if (!categoryId) return;

      const emptyVoiceChannels = guild.channels.cache.filter(
        (ch) =>
          ch.parentId === categoryId &&
          ch.id !== this.config.createVoiceChannelId &&
          ch.type === ChannelType.GuildVoice &&
          ch.members.size === 0
      );

      // Supprimer les canaux vides
      for (const [, channel] of emptyVoiceChannels) {
        await channel.delete();
        console.log(`üßπ Canal vide nettoy√©: ${channel.name}`);
      }

      console.log(`üßπ ${emptyVoiceChannels.size} canaux temporaires vides nettoy√©s`);
    } catch (error) {
      console.error('‚ùå Erreur nettoyage canaux:', error);
    }
  }

  async sendInstructions(member, channel) {
    // Canal pour les instructions
    const instructionChannelId = this.config.voiceInstructionsChannelId || member.dmChannel?.id;
    if (!instructionChannelId && !this.config.voiceInstructionsChannelId) {
      // On essaiera d'ouvrir un DM si pas de salon d√©di√©
    }

    try {
      let targetChannel;

      if (this.config.voiceInstructionsChannelId) {
        targetChannel = await this.client.channels.fetch(this.config.voiceInstructionsChannelId);
      } else {
        targetChannel = await member.createDM();
      }

      if (!targetChannel) return;

      const embed = new EmbedBuilder()
        .setTitle('üé§ Salon vocal temporaire cr√©√©')
        .setDescription(`Tu as cr√©√© un salon vocal temporaire. Tu en es le propri√©taire et tu peux le g√©rer.`)
        .addFields(
          { name: 'üë§ Propri√©taire', value: member.toString(), inline: true },
          { name: 'üîä Salon', value: channel.toString(), inline: true },
          {
            name: 'üõ†Ô∏è Commandes',
            value:
              '`/rename <nom>` - Renommer le salon\n' +
              "`/limit <nombre>` - Limiter le nombre d'utilisateurs\n" +
              '`/lock` - Verrouiller le salon\n' +
              '`/unlock` - D√©verrouiller le salon\n' +
              '`/transfer <utilisateur>` - Transf√©rer la propri√©t√©',
          }
        )
        .setColor(0x3498db)
        .setFooter({ text: 'Le salon sera supprim√© quand il sera vide' });

      await targetChannel.send({
        content: member.toString(),
        embeds: [embed],
        allowedMentions: { users: [member.id] },
      });
    } catch (error) {
      console.error('‚ùå Erreur envoi instructions vocales:', error);
    }
  }

  /** Gestion commandes slash */
  async handleSlashCommand(interaction, command) {
    const member = interaction.member;
    const channel = member.voice.channel;

    // V√©rifier si l'utilisateur est dans un canal vocal
    if (!channel) {
      return interaction.reply({
        content: '‚ùå Tu dois √™tre dans un salon vocal pour utiliser cette commande',
        ephemeral: true,
      });
    }

    // V√©rifier si c'est un canal temporaire
    const tempChannel = this.isTempChannel(channel.id) ? this.tempChannels.get(channel.id) : null;
    if (!tempChannel) {
      return interaction.reply({
        content: '‚ùå Cette commande ne fonctionne que dans les salons vocaux temporaires',
        ephemeral: true,
      });
    }

    // V√©rifier si l'utilisateur est le propri√©taire ou un administrateur
    const isAdmin = member.permissions.has(PermissionFlagsBits.Administrator);
    const isOwner = tempChannel.owner === member.id;

    if (!isAdmin && !isOwner) {
      return interaction.reply({
        content: '‚ùå Seul le propri√©taire du salon peut utiliser cette commande',
        ephemeral: true,
      });
    }

    // Traiter la commande
    switch (command) {
      case 'rename':
        return this.handleRename(interaction, channel);
      case 'limit':
        return this.handleLimit(interaction, channel);
      case 'lock':
        return this.handleLock(interaction, channel);
      case 'unlock':
        return this.handleUnlock(interaction, channel);
      case 'transfer':
        return this.handleTransfer(interaction, channel);
      default:
        return interaction.reply({
          content: '‚ùå Commande inconnue',
          ephemeral: true,
        });
    }
  }

  /** Gestion commandes texte (pr√©fixe) */
  async handleTextCommand(message, command, args) {
    const member = message.member;
    const channel = member.voice.channel;

    // V√©rifications similaires √† handleSlashCommand
    if (!channel) {
      return message.reply('‚ùå Tu dois √™tre dans un salon vocal pour utiliser cette commande');
    }

    const tempChannel = this.tempChannels.get(channel.id);
    if (!tempChannel) {
      return message.reply('‚ùå Cette commande ne fonctionne que dans les salons vocaux temporaires');
    }

    const isAdmin = member.permissions.has(PermissionFlagsBits.Administrator);
    const isOwner = tempChannel.owner === member.id;

    if (!isAdmin && !isOwner) {
      return message.reply('‚ùå Seul le propri√©taire du salon peut utiliser cette commande');
    }

    // Traiter la commande
    try {
      switch (command) {
        case 'rename':
          if (!args.length) return message.reply('‚ùå Tu dois sp√©cifier un nom');
          await channel.setName(args.join(' '));
          return message.reply(`‚úÖ Salon renomm√© en: ${args.join(' ')}`);

        case 'limit':
          {
            const limit = parseInt(args[0], 10);
            if (isNaN(limit) || limit < 0 || limit > 99) return message.reply('‚ùå Limite invalide (0-99)');
            await channel.setUserLimit(limit);
            return message.reply(`‚úÖ Limite d√©finie √†: ${limit === 0 ? 'illimit√©' : limit}`);
          }

        case 'lock':
          await channel.permissionOverwrites.edit(message.guild.id, {
            Connect: false,
          });
          return message.reply('‚úÖ Salon verrouill√©');

        case 'unlock':
          await channel.permissionOverwrites.edit(message.guild.id, {
            Connect: true,
          });
          return message.reply('‚úÖ Salon d√©verrouill√©');

        case 'transfer':
          {
            if (!args.length) return message.reply('‚ùå Tu dois mentionner un utilisateur');
            const targetId = args[0].replace(/[<@!&>]/g, '');
            const target = message.guild.members.cache.get(targetId);
            if (!target) return message.reply('‚ùå Utilisateur introuvable');
            if (!channel.members.has(target.id)) return message.reply("‚ùå L'utilisateur doit √™tre dans le salon");

            // Retirer les permissions du propri√©taire actuel
            await channel.permissionOverwrites.edit(member.id, {
              ManageChannels: false,
              MuteMembers: false,
              DeafenMembers: false,
              ManageMessages: false,
              MoveMembers: false,
            });

            // Donner les permissions au nouveau propri√©taire
            await channel.permissionOverwrites.edit(target.id, {
              ManageChannels: true,
              MuteMembers: true,
              DeafenMembers: true,
              ManageMessages: true,
              MoveMembers: true,
            });

            // Mettre √† jour le propri√©taire
            this.tempChannels.set(channel.id, {
              owner: target.id,
              created: tempChannel.created,
            });

            return message.reply(`‚úÖ Propri√©t√© du salon transf√©r√©e √† ${target.toString()}`);
          }

        default:
          return message.reply('‚ùå Commande inconnue');
      }
    } catch (error) {
      console.error(`‚ùå Erreur commande vocale ${command}:`, error);
      return message.reply('‚ùå Une erreur est survenue');
    }
  }

  // ---- Handlers slash d√©taill√©s ----

  async handleRename(interaction, channel) {
    const name = interaction.options.getString('nom');
    if (!name) {
      return interaction.reply({ content: '‚ùå Tu dois fournir un nom', ephemeral: true });
    }

    try {
      await channel.setName(name);
      return interaction.reply({
        content: `‚úÖ Salon renomm√© en: ${name}`,
        ephemeral: true,
      });
    } catch (error) {
      console.error('‚ùå Erreur rename:', error);
      return interaction.reply({
        content: '‚ùå Erreur lors du renommage du salon',
        ephemeral: true,
      });
    }
  }

  async handleLimit(interaction, channel) {
    const limit = interaction.options.getInteger('nombre');
    if (limit == null || isNaN(limit) || limit < 0 || limit > 99) {
      return interaction.reply({ content: '‚ùå Limite invalide (0-99)', ephemeral: true });
    }

    try {
      await channel.setUserLimit(limit);
      return interaction.reply({
        content: `‚úÖ Limite d√©finie √†: ${limit === 0 ? 'illimit√©' : limit}`,
        ephemeral: true,
      });
    } catch (error) {
      console.error('‚ùå Erreur limit:', error);
      return interaction.reply({
        content: '‚ùå Erreur lors de la d√©finition de la limite',
        ephemeral: true,
      });
    }
  }

  async handleLock(interaction, channel) {
    try {
      await channel.permissionOverwrites.edit(interaction.guild.id, {
        Connect: false,
      });
      return interaction.reply({
        content: '‚úÖ Salon verrouill√©',
        ephemeral: true,
      });
    } catch (error) {
      console.error('‚ùå Erreur lock:', error);
      return interaction.reply({
        content: '‚ùå Erreur lors du verrouillage du salon',
        ephemeral: true,
      });
    }
  }

  async handleUnlock(interaction, channel) {
    try {
      await channel.permissionOverwrites.edit(interaction.guild.id, {
        Connect: true,
      });
      return interaction.reply({
        content: '‚úÖ Salon d√©verrouill√©',
        ephemeral: true,
      });
    } catch (error) {
      console.error('‚ùå Erreur unlock:', error);
      return interaction.reply({
        content: '‚ùå Erreur lors du d√©verrouillage du salon',
        ephemeral: true,
      });
    }
  }

  async handleTransfer(interaction, channel) {
    const target = interaction.options.getMember('utilisateur');
    const tempChannel = this.tempChannels.get(channel.id);

    if (!target) {
      return interaction.reply({
        content: '‚ùå Utilisateur introuvable',
        ephemeral: true,
      });
    }

    if (!channel.members.has(target.id)) {
      return interaction.reply({
        content: "‚ùå L'utilisateur doit √™tre pr√©sent dans le salon",
        ephemeral: true,
      });
    }

    try {
      // Retirer les permissions du propri√©taire actuel
      await channel.permissionOverwrites.edit(interaction.user.id, {
        ManageChannels: false,
        MuteMembers: false,
        DeafenMembers: false,
        ManageMessages: false,
        MoveMembers: false,
      });

      // Donner les permissions au nouveau propri√©taire
      await channel.permissionOverwrites.edit(target.id, {
        ManageChannels: true,
        MuteMembers: true,
        DeafenMembers: true,
        ManageMessages: true,
        MoveMembers: true,
      });

      // Mettre √† jour le propri√©taire dans la Map
      this.tempChannels.set(channel.id, {
        owner: target.id,
        created: tempChannel.created,
      });

      return interaction.reply({
        content: `‚úÖ Propri√©t√© du salon transf√©r√©e √† ${target.toString()}`,
        ephemeral: true,
      });
    } catch (error) {
      console.error('‚ùå Erreur transfer:', error);
      return interaction.reply({
        content: '‚ùå Erreur lors du transfert de propri√©t√©',
        ephemeral: true,
      });
    }
  }
}

module.exports = VoiceManager;